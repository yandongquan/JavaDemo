### Java 实例

#### 目录

- [x] Hello World
- [x] 数据类型
- [x] 面向对象
- [x] 异常
- [ ] 线程
- [ ] 网络
- [ ] 注解
- [ ] 反射
- [ ] JDBC
- [ ] 设计模式
- [ ] 正则表达式
- [ ] Java8新特性





-----
# Markdown模板

# 大标题
## 副标题
### 标题1
#### 标题2
##### 标题3
###### 标题4

> 引用
>> 引用嵌套
>>> **文本效果+引用**

关键词： `Java`、`Markdown`

- [x] 复选框选中
- [ ] 复选框未选中

[超链接](https://note.youdao.com/)  
[目录索引](#目录)   
![图片比超链接多个感叹号](https://note.youdao.com/favicon.ico)

# 例子

# 石衫突击一

# 一 **分布式系统**

**分布式系统：**我用一句话给你解释一下，实在没时间多唠了，就是原来 20 万行代码的系统，现在拆分成 20 个小系统，每个小系统 1 万行代码。原本代码之间直接就是基于 spring 调用，现在拆分开来了，20 个小系统部署在不同的机器上，得基于 dubbo 搞一个 rpc 调用，接口与接口之间通过网络通信来请求和响应。就这个意思。

## 1.1 系统拆分

### 1.1.1 为什么要进行系统拆分？

一句话总结，如果是那种代码量多达几十万行的中大型项目，团队里有几十个人，那么如果不拆分系统，**开发效率极其低下，问题很多**。但是拆分系统之后，每个人就负责自己的一小部分就好了，可以随便玩儿随便弄。分布式系统拆分之后，**可以大幅度提升复杂系统大型团队的开发效率。**

### 1.2.1 说一下的dubbo的工作原理？

**dubbo工作原理**

- 第一层：service 层，接口层，给服务提供者和消费者来实现的
- 第二层：config 层，配置层，主要是对 dubbo 进行各种配置的
- 第三层：proxy 层，服务代理层，透明生成客户端的 stub 和服务单的 skeleton
- 第四层：registry 层，服务注册层，负责服务的注册与发现
- 第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务
- 第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控
- 第七层：protocol 层，远程调用层，封装 rpc 调用
- 第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步
- 第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口
- 第十层：serialize 层，数据序列化层

比如说服务A调用服务B，结果服务B挂掉了，服务A重试几次调用服务B，还是不行，直接降级，走一个备用的逻辑，给用户返回响应

```java
public interface HelloService {
   void sayHello();
}
```

### 注册中心挂了可以继续通信吗？

可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。

### 1.2.2 dubbo支持哪些序列化协议？

**1. dubbo 协议**
dubbo://192.168.0.1:20188
默认就是走 dubbo 协议的，单一长连接，NIO 异步通信，基于 hessian 作为序列化协议




